# 事务
## 事务的特性
事务ACID：
1. 原子性（Atomicity）
   一个事务中所有操作要么都做，要么都不做
2. 一致性（Consistency）
   一致性是指数据库中的数据在事务操作前和事务处理后必须满足业务规则约束
   eg：甲乙账户的总金额在转账前和转账后必须一致，如有不一致，则必须是短暂的，且只有在事务提交前才会出现。
3. 隔离性（Isolation)）
   隔离是指数据库允许多个并发事务同时对数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行导致数据不一致。
4. 持久性（Durability）
   事务处理结束后，对数据的修改是永久性，即使发生故障也不会丢失。

从本质上来说，原子性、隔离性、持久性，最终目的都是为了保证一致性。即一致性是最终目标，原子性、隔离性、持久性可以说都是为了实现这一目标的手段。
## 事务语句
事务开启语句是由begin，事务结束是以commit或者rollback显示结束
```text
begin;
DML语句
commit/rollback
```
MySql数据库可以使用autocommit=1开启自动提交，关闭手动提交。

Oracle数据库中事务不是自动提交的，而MySql为什么要关闭自动提交？
1. 不用一个事务一次提交了，提高了每秒处理事务的能力。
2. 如果过程中某个事务一直没有提交，就会导致行锁等待的现象，就会严重影响数据库的TPS值。

## truncate和delete的区别
truncate是DDL语句操作，delete是DML语句操作。
* truncate不能回滚，delete可以回滚

* truncate可以清空表的自增id属性，从1开始重新记录，而delete不会。

## 事务隔离级别
### SQL 标准定义了四个隔离级别：
```text
+-----------------+-------+--------+-------+
|   隔离级别         | 脏读 | 不可重复读 | 幻读 |
+-----------------+-------+--------+-------+
| READ-UNCOMMITTED |   √   |    √    |   √   |
| READ-COMMITTED   |   ×   |    √    |   √   |
| REPEATABLE-READ  |   ×   |    ×    |   √   |
| SERIALIZABLE     |   ×   |    ×    |   ×   |
+-----------------+-------+--------+-------+
```
#### 读未提交（read uncommitted）
在其中一个事务中，可以读取到其他事务未提交的数据变化。读取到其他还没有提交的事务叫做脏读。
#### 读已提交（read committed）
在其中一个事务中，可以读取到其他事务已经提交的数据变化。这种读取叫做不可重复读，允许幻读现象的发生，是Oracle数据库默认的事务隔离级别。
#### 可重复读（repeatable read）
在其中一个事务中，直到事务结束前，都可以读取到事务刚开始看到的数据，并一直不会发生变化，避免了脏读、不可重复读、幻读的发生
#### 串行
在每个读的数据行上都需要加表级共享锁，在每次写数据时都要加表级排他锁，并发能力严重下降

### MySql中的四个隔离级别
标准的 SQL 隔离级别定义里，REPEATABLE-READ(可重复读)是不可以防止幻读的。

但是！InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的。

主要有下面两种情况：

```text
快照读：由 MVCC 机制来保证不出现幻读。

当前读：使用 Next-Key Lock 进行加锁来保证不出现幻读，Next-Key Lock 是行锁（Record Lock）和间隙锁（Gap Lock）的结合，行锁只能锁住已经存在的行，为了避免插入新行，需要依赖间隙锁。因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 READ-COMMITTED ，但是 InnoDB 存储引擎默认使用 REPEATABLE-READ 并不会有任何性能损失。
```
### 查询InnoDB的隔离级别
MySql InnoDB存储引擎实现SQL标准的4种隔离级别。
低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。MySql数据库通过 SELECT @@tx_isolation;命令来查看，MySQL 8.0 该命令改为SELECT @@transaction_isolation; 来查看当前数据库的隔离级别
```text
+-----------------------+-----------------+
| Variable_name         | Value           |
+-----------------------+-----------------+
| transaction_isolation | REPEATABLE-READ |
+-----------------------+-----------------+
```
MySql默认的隔离级别是 REPEATABLE-READ

## 脏读、不可重复读、幻读
### 脏读
脏读是在事务隔离级别 读未提交 中出现的问题。一个事务读取到另一个正在进行中的事务提交的数据

### 不可以重复读和幻读
不可重复读指在其中一个事务中，读取到其他事务对旧数据的修改完毕的记录（常见的update和delete语句）

幻读指在一个事务中，读取到其他事务新增的数据，仿佛出现了幻影（常见insert语句）

## InnoDB如何解决的幻读

InnoDB存储引擎在 RR 级别下通过 MVCC和 Next-key Lock 来解决幻读问题：

1、执行普通 select，此时会以 MVCC 快照读的方式读取数据在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 Read View ，并使用至事务提交。所以在生成 Read View 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”

2、执行 select...for update/lock in share mode、insert、update、delete 等当前读在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！InnoDB 使用 Next-key Lockopen in new window 来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读#

## 多版本控制（MVCC）
多版本控制（Multi-Version Concurrency Control）

MVCC 是一种并发控制机制，用于在多个并发事务同时读写数据库时保持数据的一致性和隔离性。它是通过在每个数据行上维护多个版本的数据来实现的。

当一个事务要对数据库中的数据进行修改时，MVCC 会为该事务创建一个数据快照，而不是直接修改实际的数据行。

### 1. 读操作
当一个事务执行读操作时，它会使用快照读取。

快照读取是基于事务开始时数据库中的状态创建的，因此事务不会读取其他事务尚未提交的修改。

具体为：
1. 事务会查找符合条件的数据行，并选择符合其事务开始时间的数据版本进行读取。
2. 如果某个数据行有多个版本，事务会选择不晚于其开始时间的最新版本，确保事务只读取在它开始之前已经存在的数据。
3. 事务读取的是快照数据，因此其他并发事务对数据行的修改不会影响当前事务的读取操作。

### 2. 写操作（INSERT、UPDATE、DELETE）
当一个事务执行写操作时，它会生成一个新的数据版本，并将修改后的数据写入数据库

具体为：
1. 对于写操作，事务会为要修改的数据行创建一个新的版本，并将修改后的数据写入新版本。
2. 新版本的数据会带有当前事务的版本号，以便其他事务能够正确读取相应版本的数据。

### 3. 事务提交和回滚
1. 当一个事务提交时，它所做的修改将成为数据库的最新版本，并且对其他事务可见。
2. 当一个事务回滚时，它所做的修改将被撤销，对其他事务不可见。

### 4. 版本的回收
为了防止数据库中的版本无限增长，MVCC 会定期进行版本的回收。回收机制会删除已经不再需要的旧版本数据，从而释放空间。

MVCC 通过创建数据的多个版本和使用快照读取来实现并发控制。读操作使用旧版本数据的快照，写操作创建新版本，并确保原始版本仍然可用。这样，不同的事务可以在一定程度上并发执行，而不会相互干扰，从而提高了数据库的并发性能和数据一致性。#

### InnoDB 对 MVCC 的实现


## 非锁定读 & 锁定读
### 非锁定读（快照读）
在 InnoDB 存储引擎中，多版本控制 就是对非锁定读的实现。

如果读取的行正在执行 DELETE 或 UPDATE 操作，这时读取操作不会去等待行上锁的释放。相反地，InnoDB 存储引擎会去读取行的一个快照数据，对于这种读取历史数据的方式，我们叫它快照读 (snapshot read)

在 Repeatable Read 和 Read Committed 两个隔离级别下，如果是执行普通的 select 语句（不包括 select ... lock in share mode ,select ... for update）则会使用 一致性非锁定读（MVCC）。 并且在 Repeatable Read 下 MVCC 实现了可重复读和防止部分幻读

### 锁定读（当前读）
如果执行的是下列语句，就是 锁定读
```text
select ... lock in share mode 
select ... for update 
insert、update、delete 操作
```
在锁定读下，读取的是数据的最新版本，这种读也被称为 当前读（current read）。

锁定读会对读取到的记录加 S 锁, 如果加 x 锁则会被阻塞select ... for update、insert、update、delete，即使读取的记录已被其它事务加上 X 锁，这时记录也是可以被读取的，即读取的快照数据。

上面说了，在 Repeatable Read 下 MVCC 防止了部分幻读，这边的 “部分” 是指在快照读情况下，只能读取到第一次查询之前所插入的数据。但是！如果是当前读 ，每次读取的都是最新数据，这时如果两次查询中间有其它事务插入数据，就会产生幻读。所以， InnoDB 在实现Repeatable Read 时，如果执行的是当前读，则会对读取的记录使用 Next-key Lock ，来防止其它事务在间隙间插入数据

