## 判断对象为垃圾的算法
当对象没有任何引用的时候就会被判定为垃圾
## 找垃圾的算法
### 引用计数算法
对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；
很少被用。主要原因是，需配合大量额外处理才能保证正确地工作，例如：就很难解决对象之间相互循环引用的问题。

### 可达性分析算法（根可达算法）
#### 根对象：
在Java中，根对象指的是一组被虚拟机内部直接引用的对象，这些对象可以作为可达性分析的起点，从而找到所有被引用的对象。根对象包括如下几种类型：
* 线程栈变量：虚拟机栈（或本地方法栈）中引用的对象，即正在执行的方法中使用到的参数、局部变量等。
* 静态变量：被声明为static的对象。
* 常量池：方法区中常量引用的对象，如字符串常量池中的字符串对象等。
* JNI指针：本地方法栈中JNI（Java Native Interface）引用的对象，即JNI方法中使用到的对象。

## 垃圾清除算法

### 标记-清除算法

算法相对简单，存活对象较多的情况下效率较高

两个主要缺点是：

1. 执行效率不稳定。Java堆中包含大量对象,而且其中大部分是需要被回收的,导致标记和清除两个过程的执行效率都随对象数量增长而降低。
2. 内存空间碎片化。标记和清除过程完成后可能会产生大量不连续的内存碎片，导致后续程序无法找到足够的连续内存，需要触发另一次垃圾收集动作。

### 标记-复制算法

* 原理：
  将内存划为两块内存大小相同的区域，每次只使用其中的一块。将活着的移动到另一半，然后将剩下的一半清除掉。

* 缺点：
  解决了标记-清除算法的两个缺点，但是可用内存缩小为原来的一半，空间浪费大。

* 原理： 
  1. **现在的商用Java虚拟机大多使用该算法去回收新生代**。一般新生代中的对象有98%熬不过第一轮收集。
  2. 将Eden和Survivor中存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的Survivor空间。
  3. HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1。
* 分配担保
  为了防止Survivor空间不足：还有一个“逃生门”的安全设计，当Survivor空间不足以容纳一次MinorGC之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保（Handle Promotion）。

* 适用的内存区域：一般用于新生代，老年代不使用。

标记-复制算法在对象存活率高时需要进行大量复制操作，效率下降。为应对所有对象都100%存活的情况，需要额外分配空间，因此老年代一般不采用此算法。

### 标记-整理算法

原理：标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存

没有碎片，但是需要扫描两次，效率低。

## 常见的垃圾回收器
![](images/垃圾回收器分类.png ':size=200x100')

### 常见垃圾回收器组合参数设定