## VM
### HotSpot VM
它是Sun/OracleJDK和OpenJDK中的默认Java虚拟 机，也是目前使用范围最广的Java虚拟机。

Java“天下第一”的底气不 在于语法多么先进好用，而是来自它庞大的用户群和极其成熟的软件生态，这在朝夕之间难以撼动。

新一代即时编译器 
对需要长时间运行的应用来说，由于经过充分预热，热点代码会被HotSpot的探测机制准确定位捕 获，并将其编译为物理硬件可直接执行的机器码，在这类应用中Java的运行效率很大程度上取决于即 时编译器所输出的代码质量。


HotSpot虚拟机中含有两个即时编译器：分别是编译耗时短但输出代码优化程度较低的客户端编译 器（简称为C1）以及编译耗时长但输出代码优化质量也更高的服务端编译器（简称为C2）
自JDK 10起，HotSpot中又加入了一个全新的即时编译器：Graal编译器

第二部分 自动内存管理 ·
第2章 Java内存区域与内存溢出异常 
### 2.2 运行时数据区域
![](images/Java虚拟机运行时数据区.png ':size=500x500')
2.2.1 程序计数器

2.2.2 Java虚拟机栈
Java虚拟机栈（Java Virtual Machine Stack）也是线程私有的，它的生命周期 与线程相同。
虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都 会同步创建一个栈帧[1]（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信 息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、 float、long、double）、对象引用（reference类型，它并不等同于对象本身，可能是一个指向对象起始 地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress 类型（指向了一条字节码指令的地址）。

这些数据类型在局部变量表中的存储空间以局部变量槽（Slot）来表示，其中64位长度的long和 double类型的数据会占用两个变量槽，其余的数据类型只占用一个。局部变量表所需的内存空间在编 译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定 的，在方法运行期间不会改变局部变量表的大小。请读者注意，这里说的“大小”是指变量槽的数量， 虚拟机真正使用多大的内存空间（譬如按照1个变量槽占用32个比特、64个比特，或者更多）来实现一 个变量槽，这是完全由具体的虚拟机实现自行决定的事情。 在《Java虚拟机规范》中，对这个内存区域规定了两类异常状况：如果线程请求的栈深度大于虚 拟机所允许的深度，将抛出StackOverflowError异常；如果Java虚拟机栈容量可以动态扩展[2]，当栈扩 展时无法申请到足够的内存会抛出OutOfMemoryError异常。

HotSpot虚拟机的栈容量是不可以动态扩展的，以前的Classic虚拟机倒是可以。所以在HotSpot虚拟 机上是不会由于虚拟机栈无法扩展而导致OutOfMemoryError异常——只要线程申请栈空间成功了就不 会有OOM，但是如果申请时就失败，仍然是会出现OOM异常的

2.2.3 本地方法栈
本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机 栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native） 方法服务。

《Java虚拟机规范》对本地方法栈中方法使用的语言、使用方式与数据结构并没有任何强制规 定，因此具体的虚拟机可以根据需要自由实现它，甚至有的Java虚拟机（譬如Hot-Spot虚拟机）直接 就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失 败时分别抛出StackOverflowError和OutOfMemoryError异常。

2.2.4 Java堆
此内存区域的唯一目的就是存放对象实例。Java堆是垃圾收集器管理的内存区域，因此一些资料中它也被称作“GC堆”

2.2.5 方法区
方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载 的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。
《Java虚拟机规范》对方法区的约束是非常宽松的，除了和Java堆一样不需要连续的内存和可以选 择固定大小或者可扩展外，甚至还可以选择不实现垃圾收集。
“永久代”
JDK 8以前，许多Java程序员愿意把方法区称呼为“永久代”。本质上这两者并不是等价的，因为仅仅是当时的HotSpot虚拟机设 计团队选择把收集器的分代设计扩展至方法区，或者说使用永久代来实现方法区而已，这样使得 HotSpot的垃圾收集器能够像管理Java堆一样管理这部分内存，省去专门为方法区编写内存管理代码的 工作。
原则 上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一。
考虑到HotSpot未来的发展，在JDK 6的 时候HotSpot开发团队就有放弃永久代，逐步改为采用本地内存（Native Memory）来实现方法区的计 划了[1]，到了JDK 7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，而到了 JDK 8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Meta- space）来代替，把JDK 7中永久代还剩余的内容（主要是类型信息）全部移到元空间中。


2.2.6 运行时常量池
运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字 段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生 成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。

2.2.7 直接内存
直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中 定义的内存区域。在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区 （Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存

2.3 HotSpot虚拟机对象探秘
2.3.1 对象的创建
2.3.2 对象的内存布局
在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。
对象头：
    存储两类数据：第一类是用于存储对象自身的运行时数据； 哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等
                对象头的另外一部分是类型指针；即对象指向它的类型元数据的指针，Java虚拟机通过这个指针 来确定该对象是哪个类的实例。
2.3.3 对象的访问定位
创建对象自然是为了后续使用该对象，我们的Java程序会通过栈上的reference（引用）数据来操作堆上的具体对象。
主流的访问方式主要有使用句柄和直接指针两种：
·如果使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就 是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息，其结构如图2-2所示。
这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference本身不需要被修改。
![](images/通过句柄访问对象.png ':size=100x100')
·如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问 的开销，如图2-3所示。
使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本，HotSpot采用此方式
![](images/通过直接指针访问对象.png ':size=100x100')
2.4 OutOfMemoryError异常
2.4.1 出现Java堆内存 溢出时，异常堆栈信息“java.lang.OutOfMemoryError”会跟随进一步提示“Java heap space”。
2.4.2 虚拟机栈和本地方法栈溢出
由于HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此对于HotSpot来说，-Xoss参数（设置 本地方法栈大小）虽然存在，但实际上是没有任何效果的，栈容量只能由-Xss参数来设定。
关于虚拟 机栈和本地方法栈，在《Java虚拟机规范》中描述了两种异常： 
    1）如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。 
2）如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出 OutOfMemoryError异常。
2.4.3 方法区和运行时常量池溢出
2.4.4 本机直接内存溢出

第3章 垃圾收集器与内存分配策略
3.1 判断对象是否死了
3.2.1 引用计数算法
在对象中添加一个引用计数器，每当有一个地方 引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可 能再被使用的。
主流的Java虚拟机里面都没有选用引用计数算法来管理内存，主要原因是，这个看似简单 的算法有很多例外情况要考虑，必须要配合大量额外处理才能保证正确地工作，譬如单纯的引用计数 就很难解决对象之间相互循环引用的问题。
eg：
    testGC()方法：对象objA和objB都有字段instance，赋值令 objA.instance=objB及objB.instance=objA，除此之外，这两个对象再无任何引用，实际上这两个对象已 经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为零，引用计数算法也 就无法回收它们。
3.2.2 可达性分析算法

啊？没看懂啊？继续看

3.2.3 再谈引用
在JDK 1.2版之前，如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该reference数据是代表 某块内存、某个对象的引用。
在JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为强引用（Strongly Re-ference）、软 引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4种，这4种引用强 度依次逐渐减弱。
    强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj=new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回 收掉被引用的对象。
    软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内 存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存， 才会抛出内存溢出异常。
    弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只 能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只 被弱引用关联的对象。
    为一个对象设置虚 引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。
3.2.4 生存还是死亡？
3.2.5 回收方法区
有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，《Java虚 拟机规范》中提到过可以不要求虚拟机在方法区中实现垃圾收集，事实上也确实有未实现或未能完整 实现方法区类型卸载的收集器存在（如JDK 11时期的ZGC收集器就不支持类卸载），方法区垃圾收集 的“性价比”通常也是比较低的：在Java堆中，尤其是在新生代中，对常规应用进行一次垃圾收集通常 可以回收70%至99%的内存空间，相比之下，方法区回收囿于苛刻的判定条件，其区域垃圾收集的回 收成果往往远低于此。

3.3 垃圾收集算法
从如何判定对象消亡的角度出发，垃圾收集算法可以划分为
“引用计数式垃圾收集”（Reference Counting GC）和“追踪式垃圾收集”（Tracing GC）两大类，这两类也常被称作“直接垃圾收集”和“间接 垃圾收集”。由于引用计数式垃圾收集算法在本书讨论到的主流Java虚拟机中均未涉及
3.3.1 分代收集理论
当前商业虚拟机的垃圾收集器，大多数都遵循了“分代收集”（Generational Collection）[1]的理论进 行设计
1）弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。 
2）强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。
3）跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。

跨代引用假说产生的原因：
    假如要现在进行一次只局限于新生代区域内的收集（Minor GC），但新生代中的对象是完全有可能被老年代所引用的，为了找出该区域中的存活对象，不得不在固定的GC Roots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，反过来也是一样[3]。
    遍历整个老年代所有对象 的方案虽然理论上可行，但无疑会为内存回收带来很大的性能负担。 由此跨代引用假说 引出了一个新的数据结构：记忆集（Remembered Set） 记忆集中存放的是指向老年代对象的引用。

3.3.2 标记-清除算法
最早出现也是最基础的垃圾收集算法是“标记-清除”（Mark-Sweep）算法
两个主要缺点是：
    1. 执行效率不稳定。Java堆中包含大量对象,而且其中大部分是需要被回收的,导致标记和清除两个过程的执行效率都随对象数量增长而降低。
    2. 内存空间碎片化。标记和清除过程完成后可能会产生大量不连续的内存碎片，导致后续程序无法找到足够的连续内存，需要触发另一次垃圾收集动作。

3.3.3 标记-复制算法
将内存划为两块内存大小相同的区域，每次只使用其中的一块。将活着的移动到另一半，然后将剩下的一半清除掉。
解决了标记-清除算法的两个缺点，但是可用内存缩小为了原来的一半，空间浪费大。

**现在的商用Java虚拟机大多采用了这种收集算法去回收新生代**，IBM统计过：新生代中的对象有98%熬不过第一轮收集。因此并不需要按照1∶1的比例来划分新生代的内存空间。
"Appel式回收"：Andrew Appel提出：把新生代分为一块较大的Eden空间和两块较小的Survivor空间。发生垃圾搜集时，将Eden和Survivor中存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的Survivor空间。
HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，
为了防止Survivor空间不足：Appel式回收还有一个充当罕见情况的“逃生门”的安全设计，当Survivor空间不足以容纳一次MinorGC之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保（Handle Promotion）。

标记-复制算法在对象存活率高时需要进行大量复制操作，效率下降。为应对所有对象都100%存活的情况，需要额外分配空间，因此老年代一般不采用此算法。

3.3.4 标记-整理算法
标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可 回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存

3.4 HotSpot的算法细节实现
这个我先跳过了

3.5 经典垃圾收集器
收集算法是内存回收的方法论，垃圾收集器就是内存回收的实践者。不存在“万能”的收集器，所以我们选择的只是对具体应用最合适的收集器。
3.5.1 Serial收集器
3.5.2 ParNew收集器

3.5.7 Garbage First收集器

G1 收集器
G1跳出了收集目标不是新生代就是其他代，而是面向堆，那块内存的垃圾最多就回收：
    在G1收集器出现之前的所有 其他收集器，包括CMS在内，垃圾收集的目标范围要么是整个新生代（Minor GC），要么就是整个老 年代（Major GC），再要么就是整个Java堆（Full GC）。
    而G1跳出了这个樊笼，它可以面向堆内存任 何部分来组成回收集（Collection Set，一般简称CSet）进行回收，衡量标准不再是它属于哪个分代，而 是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式。
基石：G1基于Region的堆内存布局

G1收集器的 运作过程大致可划分为以下四个步骤：
* 初始标记（Initial Marking）：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS 指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要 停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际 并没有额外的停顿。 
* 并发标记（Concurrent Marking）：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆 里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以 后，还要重新处理SATB记录下的在并发时有引用变动的对象。 
* 最终标记（Final Marking）：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留 下来的最后那少量的SATB记录。 
* 筛选回收（Live Data Counting and Evacuation）：负责更新Region的统计数据，对各个Region的回 收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region 构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧 Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行 完成的。

可以由用户指定期望的停顿时间
    可使得G1在不同应用场景中取得关注吞吐量和关注延迟之间的最佳平衡，默认的停顿目标为两百毫秒。通常把期望停顿时间设置为一两百毫秒或者两三百毫秒会是比较合理的。
    如果把停顿时间调得非常低，譬如设置为二十毫秒，很可能出现停顿目标时间太短，导致每次选出来的回收集只占堆内存很小的一部分，收集器收集的速度逐渐跟不上分配器分配的速度，导致垃圾慢慢堆积，最终占满堆引发Full GC反而降低性能，


3.6 低延迟垃圾收集器

衡量垃圾收集器的三项最重要的指标是：
    内存占用（Footprint）
    吞吐量（Throughput）
    延迟 （Latency）
    三者共同构成了一个“不可能三角” 但是低延迟

3.6.1 Shenandoah收集器

3.6.2 ZGC收集器

3.7 选择合适的垃圾收集器

3.7.3 虚拟机及垃圾收集器日志
在JDK 9以前，HotSpot并没 有提供统一的日志处理框架，虚拟机各个功能模块的日志开关分布在不同的参数上，日志级别、循环 日志大小、输出格式、重定向等设置在不同功能上都要单独解决。直到JDK 9，HotSpot所有功能的日志都收归到了“-Xlog”参数上。

3.7.4 垃圾收集器参数总结

### 第4章 虚拟机性能监控、故障处理工具
#### 4.2.1 jps：虚拟机进程状况工具
可以列出正在运行的虚拟机进程，并显示虚拟机执行主类（Main Class，main()函数所在的类）名称以及这些进程的本地虚拟机唯一 ID（LVMID，Local Virtual Machine Identifier）。
##### jps命令格式：
```shell
# options 表示可选参数，hostid 表示要查询的主机名或进程 ID
jps [ options ] [ hostid ]
```
##### jps命令主要有以下选项：
```text
-q：只输出Java应用程序的进程ID，不显示进程名称。
-m：输出虚拟机进程启动时传递给主类main()函数的参数
-l：输出Java应用程序的完全包名或应用程序的JAR文件路径。
-v：输出Java应用程序的启动参数以及传递给Java虚拟机的参数。
```

#### 4.2.2 jstat：虚拟机统计信息监视工具
jstat（JVM Statistics Monitoring Tool）是用于监视虚拟机各种运行状态信息的命令行工具。它可 以显示本地或者远程虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据
##### 命令格式
```shell
jstat [ option vmid [interval[s|ms] [count]] ]
```

eg：每250毫秒查询进程7的垃圾回收情况并打印20次
```shell
jstat -gc 7 250 20
```
```shell
S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU      CCSC   CCSU       YGC    YGCT   FGC    FGCT     GCT   
5120.0 5120.0 5108.1  0.0   76800.0  27996.3   87552.0    13596.5   31616.0 29347.3 4224.0 3780.3      4    0.021   1      0.015    0.036
```
```text
S0C：第一个幸存区的容量（KB）
S1C：第二个幸存区的容量（KB）
S0U：第一个幸存区已经使用的空间（KB）
S1U：第二个幸存区已经使用的空间（KB）
EC：伊甸园区（Eden Space）的容量（KB）
EU：伊甸园区已经使用的空间（KB）
OC：老年代（Old Gen）的容量（KB）
OU：老年代已经使用的空间（KB）
MC：元数据区（Metadata Space）的容量（KB）
MU：元数据区已经使用的空间（KB）
CCSC：压缩类空间的容量（KB）
CCSU：压缩类空间已经使用的空间（KB）
YGC：从应用程序启动到采样时发生 Young GC 的次数
YGCT：从应用程序启动到采样时用于 Young GC 的时间（秒）
FGC：从应用程序启动到采样时发生 Full GC 的次数
FGCT：从应用程序启动到采样时用于 Full GC 的时间（秒）
GCT：从应用程序启动到采样时用于垃圾回收的总时间（秒）
```

##### 启动jar并开启监控
```shell
java -jar yourApp.jar &
jstat -gcutil `pgrep -f yourApp.jar` 1000 > jstat.log &
```

##### 查询其他信息
```text
-class：显示类加载、卸载及垃圾回收等与类加载器相关的信息。

-gc：显示与 Java 堆内存管理相关的信息。包括堆的使用情况、垃圾回收次数、时间等信息。

-gccapacity：显示堆内存容量及使用情况，包括新生代、老年代、持久代等。

-gctt：显示垃圾回收统计信息，包括垃圾回收时间、次数、耗时等。

-gcutil：显示垃圾回收统计信息及堆内存使用情况等信息。其中 gcutil 后面可以跟上多个参数，用空格分隔，比如：
gcutil capacity：显示堆内存容量及使用情况
gcutil time：显示垃圾回收时间和次数
gcutil 还可以加上 -t 参数，表示每次输出间隔的时间，单位为毫秒，默认为 1000ms。

-gcnew：显示新生代内存使用情况及垃圾回收相关信息。

-gclnewcapacity：显示新生代内存容量及使用情况。

-gcold：显示老年代内存使用情况及垃圾回收相关信息。

-gcoldcapacity：显示老年代内存容量及使用情况。

-gcpermcapacity：显示持久代内存容量及使用情况。

-compiler：显示 JIT 编译器编译信息，包括编译时间、编译方法等。

-printcompilation：显示已经被 JIT 编译的方法的信息。
```
#### 4.2.3 jinfo：Java配置信息工具
jinfo（Configuration Info for Java）的作用是实时查看和调整虚拟机各项参数。

#### 4.2.4 jmap：Java内存映像工具
jmap（Memory Map for Java）命令用于生成堆转储快照（一般称为heapdump或dump文件）。

eg:
生成Java堆转储文件：
```shell
jmap -dump:format=b,file=<filename>.hprof <pid>
```
其中，<pid>是Java进程的进程ID，<filename>是要保存的堆转储文件名。

请注意，在使用jmap生成Java堆转储文件之前，请确保Java进程已启动，并且具有足够的可用内存来生成转储文件。生成转储文件会暂停Java进程的运行，因此请在非生产环境中使用它，以避免影响应用程序的性能。同时，堆转储文件可能非常大，因此请确保你有足够的磁盘空间来存储它们。

#### 4.2.5 jhat：虚拟机堆转储快照分析工具
JDK提供jhat（JVM Heap Analysis Tool）命令与jmap搭配使用，来分析jmap生成的堆转储快照。 

jhat内置了一个微型的HTTP/Web服务器，生成堆转储快照的分析结果后，可以在浏览器中查看。

工作中一般没有人来分析堆转储快照文件

#### 4.2.6 jstack：Java堆栈跟踪工具
线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的 目的通常是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间挂 起等。

#### 4.2.7 jcmd：检查和控制 Java 进程
cmd 是 Java 命令行工具中的一个命令，用于检查和控制 Java 进程。它可以列出当前系统上正在运行的 Java 进程，并显示进程的 ID 和名称。此外，jcmd 还可以向某个 Java 进程发送诊断命令。

以下是 jcmd 的一些常见用法：

```text
列出当前正在运行的 Java 进程：jcmd

列出指定进程的所有诊断命令：jcmd <pid> help

显示指定进程的 JVM 版本信息：jcmd <pid> VM.version

显示指定进程的线程堆栈信息：jcmd <pid> Thread.print

导出指定进程的堆转储文件：jcmd <pid> GC.heap_dump <filename>
```
eg:
```shell
# JVM内存使用情况
jcmd <PID> GC.heap_info
```
```shell
PSYoungGen      total 81920K, used 39376K [0x00000000fab00000, 0x0000000100000000, 0x0000000100000000)
  eden space 76800K, 44% used [0x00000000fab00000,0x00000000fcc77328,0x00000000ff600000)
  from space 5120K, 99% used [0x00000000ffb00000,0x00000000ffffd040,0x0000000100000000)
  to   space 5120K, 0% used [0x00000000ff600000,0x00000000ff600000,0x00000000ffb00000)
 ParOldGen       total 87552K, used 13596K [0x00000000f0000000, 0x00000000f5580000, 0x00000000fab00000)
  object space 87552K, 15% used [0x00000000f0000000,0x00000000f0d471d0,0x00000000f5580000)
 Metaspace       used 32431K, capacity 34646K, committed 34816K, reserved 1079296K
  class space    used 4155K, capacity 4593K, committed 4608K, reserved 1048576K
```
```text
这是一个 Java 应用程序的内存信息。具体来说，这里展示了该应用程序在堆空间（Heap Space）中的内存分配情况，以及方法区（Metaspace）和类加载器所使用的内存情况。

PSYoungGen 表示 Parallel Scavenge （并行垃圾收集器）新生代的情况。total 字段表示新生代总共的大小，used 字段表示已经被占用的大小。然后 eden space、from space 和 to space 分别表示 Eden 区、Survivor 区 From 和 Survivor 区 To 的情况，其中 eden space 和 from space 已经被占用了 44% 和 99%。

ParOldGen 表示 Parallel Old （并行老年代垃圾收集器）老年代的情况。total 字段表示老年代总共的大小，used 字段表示已经被占用的大小。object space 字段表示对象占用的大小，15% 被占用。

Metaspace 表示方法区的情况。used 字段表示已经被占用的大小，capacity 字段表示 Metaspace 总共可以扩展的大小，committed 字段表示已经分配给方法区的大小，而 reserved 字段则表示为方法区保留的地址空间的大小。

class space 表示类加载器所使用的堆空间的情况。used 字段表示已经被占用的大小，capacity 字段表示类加载器所需的大小，committed 字段表示已经分配给类加载器的大小，而 reserved 字段则表示为类加载器保留的地址空间的大小。
```


第5章 调优案例分析与实战
-XX：+HeapDumpOnOutOfMemoryError   用于在JVM内存溢出(OOM)错误发生时，自动生成堆转储文件(Heap Dump)。

#### 查看系统日志
jvm虚拟机进程崩溃 我想查看linux宿主机系统日志 如何查看？
tail -f /var/log/messages：实时查看系统的一般性消息。
tail -f /var/log/syslog：实时查看大部分的系统日志消息。

## 第三部分 虚拟机执行子系统
### 第6章 类文件结构  （真的看不懂）

#### 无关性
代码编译将本地机器码转变为字节码

“一次编写，到处运行 （Write Once，Run Anywhere）”

实现语言无关性的基础仍然是虚拟机和字节码存储格式。

Java虚拟机不与包括Java语言在内的任何程序语言绑定，它只与“Class文件”这种特定的二进制文件格式所关联，Class文件中包含了Java虚拟机 指令集、符号表以及若干其他辅助信息。

虚拟机丝毫不关心Class的来源是什么语言

java-->javac编译器-->*.class字节码-->Java虚拟机

#### Class类文件的结构
任何一个Class文件都对应着唯一的一个类或接口的定义信息
Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文件之中，没有空隙存在。
Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：“无符号数”和“表”。
##### 6.3.1 魔数与Class文件的版本
每个Class文件的头4个字节被称为魔数（Magic Number），值为0xCAFEBABE（咖啡宝贝？），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。
```text
public class Test { 
    private int m; 
    public int inc() { return m + 1; 
    }
}
```
![](images/Testclass.png ':size=500x500')
如上图使用javac编译Test.java文件然后使用vim打开，输入:%!xxd进入16进制视图

前四个字节是：魔数ca fe ba be

第5和第6字节： 次版本号 值为0x0000

第7和第8字节：主版本号 0x0034     十进制是52 对应 jdk1.8
##### 6.3.2 常量池
看不懂？？？？



##### 6.3.3 访问标志
没有看懂？？？

##### 6.3.4 类索引、父类索引与接口索引集合

##### 6.3.5 字段表集合

##### 6.3.6 方法表集合

##### 6.3.7 属性表集合

#### 6.4 字节码指令简介
##### 6.4.1 字节码与数据类型
大部分指令都没有支持整数类型byte、char和short，甚至没有任何指令 支持boolean类型。编译器会在编译期或运行期将byte和short类型的数据带符号扩展（Sign-Extend）为 相应的int类型数据，将boolean和char类型数据零位扩展（Zero-Extend）为相应的int类型数据。与之类 似，在处理boolean、byte、short和char类型的数组时，也会转换为使用对应的int类型的字节码指令来 处理。因此，大多数对于boolean、byte、short和char类型数据的操作，实际上都是使用相应的对int类 型作为运算类型（Computational Type）来进行的。

##### 6.4.2 加载和存储指令
加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈（见第2章关于内存区域的介绍）之 间来回传输，这类指令包括：
##### 6.4.3 运算指令
算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。
##### 6.4.4 类型转换指令
##### 6.4.5 对象创建与访问指令
##### 6.4.6 操作数栈管理指令
##### 6.4.7 控制转移指令
### 第7章 虚拟机类加载机制










### 第8章 虚拟机字节码执行引擎 
### 第9章 类加载及执行子系统的案例与实战